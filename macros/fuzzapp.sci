function fls=fuzzapp(order,domain_i,domain_o,partitions,f,df)
//Multi-Input Single Output Fuzzy Approximation of a Function.
//Calling Sequence
//fls=fuzzapp( order , domain_i , domain_o , partitions , f [,df] )
//Parameters
//fls:fls structure.
// order:integer. 1 for first order, 2 for second order.
// domain_i:matrix of real with dimensions [ninputs,2], were ninputs mean the number of inputs. Each row have two elements in the form [minDom maxDom], where minDom meand the minimum value who take the input, and maxDom the maximum value.
// domain_o:row vector with two elements in the form [minDom maxDom]. minDom means the minimum value of the output, and maxDom the maximum value.
// partitions:column vector with the number or partitions for each input. partitions(j) is the number of partitions for the j input.
// f:function. The function to approximate. The result of f must be a scalar.This function must be vectorized, y=f(X) where X=[value1 , value2 , .... , value_ni] , ni=number of inputs
// df:function. The Jacobian of f. This function is required if order is equal to 2.
//Description
//<literal>fuzzapp </literal> create a Fuzzy Approximation for the function
//    <literal>f</literal>.
//Examples
// // The function to approximate
//deff("y=f(x)","y=sin(x)");
// fls=fuzzapp(1,[-%pi %pi],[-1 1],10,f);
// x=linspace(-%pi,%pi,100)';
// Y_real=f(x);
// Y_fuzz=evalfls(x,fls);
// scf();clf();
// subplot(2,1,1);
// plot2d(x,[Y_real Y_fuzz],leg="real@approximation");
// xtitle("Fuzzy Approximation","x","y=f(x)");
// subplot(2,1,2);
// plot2d(x,abs(Y_real-Y_fuzz));
// xtitle("Approximation Error","x","error");
// Authors
// Jaime Urzua Grez
// Holger Nahrstaedt


// ----------------------------------------------------------------------
// Generate a fuzzy approximation
// ----------------------------------------------------------------------
// Multi-Input Single Output
// This file is part of sciFLT ( Scilab Fuzzy Logic Toolbox )
// Copyright (C) @YEARS@ Jaime Urzua Grez
// mailto:jaime_urzua@yahoo.com
// 
// 2011 Holger Nahrstaedt
// ----------------------------------------------------------------------
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
// ----------------------------------------------------------------------

// CHECK PARAMETERS
if (argn(2)<5) then
	error("fuzzap need at least 5 parameters.");
end

if ((order~=1)&(order~=2)) then
	error("Unknow order.");
end

if ((size(domain_i,2)~=2)&(size(domain_o,2)~=2)) then
	error("Incorrect domain for input and/or output!");
end

if (size(domain_i,1)~=size(partitions,1)) then
	error("The number or partitions is not equal to number of inputs.");
end

if ((typeof(f)~="function")&(typeof(f)~="fptr")) then
	error("The f parameter must be a function.");
end

if ((order==2)&(argn(2)~=6)) then
	error("For second order need df parameter.");
end

if (order==2)&((typeof(df)~="function")&(typeof(df)~="fptr")) then
	error("The df parameter must be a function.");
end


// Create default output
fls=newfls("ts","Generated by fuzzapp");

// Create the Inputs
for j=1:size(domain_i,1),
	fls=addvar(fls,"input","X_"+string(j),domain_i(j,:));
	fls=unifdis(fls,"input",j,"trimf","x_"+string(j),partitions(j))
end

// Create the outputs and the rules
rule=(1:partitions($))';
for h=size(partitions,"*")-1:-1:1,
	q1=ones(size(rule,1),1);
	q2=(1:partitions(h))';
	rule=[ q2.*.q1 ones(q2).*.rule];
end

nrules=prod(partitions);
rule=[rule (1:nrules)' ones(nrules,1) ones(nrules,1)];
ninputs=size(partitions,"*");

fls=addvar(fls,"output","Y",domain_o);

dX=(domain_i(:,2)-domain_i(:,1))./(partitions-1);
dX=dX';
X0=domain_i(:,1)';

// I use the same declaration as addmf to gain some time
if order==1 then
	flsmf=tlist(['flsmf','name','type','par'],"","constant",[]);
else
	flsmf=tlist(['flsmf','name','type','par'],"","linear",[]);
end
ou=list();
for j=1:nrules,
	X=X0+dX.*(rule(j,1:ninputs)-1);
	flsmf.name="y_"+string(j);
	if (order==1) then
		flsmf.par=f(X);
	else
		flsmf.par=[df(X) -sum(df(X).*X)+f(X)]; 
	end
	ou($+1)=flsmf;
end
fls.output(1).mf=ou;
fls.rule=rule;

endfunction
